{"version":3,"file":"worker.min.js","sources":["CPU/CPU-test-event.js","common/utils.js","CPU/worker.js"],"sourcesContent":["export const START_TEST = 0;\nexport const STOP_TEST = 1;\nexport const RESULT_SUCCESS = 2;\nexport const RESULT_FAILED = 3;\nexport const TEST_RUNNING = 4;\nexport const TEST_STOPPED = 5;\nexport const WORKER_READY = 6;","\nexport const isFunction = func => (typeof func) === \"function\";\n\nexport const isAbsent = value => (value === undefined) || (value === null);\n\n// For array, set or map-like objects\nexport const isEmpty = value => (value.size === 0) || (value.length === 0);\n\n/**\n * Shallow immutability for pure data carriers. Use sparingly.\n */\nexport const Î¾ = anyObj => Object.freeze(Object.assign(Object.create(null), anyObj));\n\n// Unclamped setTimeout using MessageChannel (For throttling behaviour: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout#Notes)\n// Creates \"macro\" tasks, which plays nicer with the main UI thread: (For macro/micro distinction: https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/queueMicrotask)\nconst channel = new MessageChannel();\nconst receiver = channel.port1;\nconst sender = channel.port2;\n\n// In an earlier project, I've tested that map here is faster than array or plain objects in both Firefox and Chrome.\n// Not sure if it's still true, but the difference wasn't big.\nconst queuedTasks = new Map();\nlet nextTaskID = 0;\n\nreceiver.onmessage = event => {\n\tconst taskID = event.data;\n\tif (queuedTasks.has(taskID)) {\n\t\t// Run if not cancelled\n\t\tconst task = queuedTasks.get(taskID);\n\t\tqueuedTasks.delete(taskID);\n\t\ttask();\n\t}\n};\n\n/**\n * @returns The id of the given task, which can be used to cancel that task\n */\nexport const queueTask = func => {\n\tif (!isFunction(func)) {\n\t\tthrow new Error(\"Not a function\");\n\t}\n\n\tconst currentID = nextTaskID;\n\t++nextTaskID;\n\tqueuedTasks.set(currentID, func);\n\tsender.postMessage(currentID);\n\n\treturn currentID;\n};\n\n/**\n * @returns True if the task was in the queue and is now removed, false if the id doesn't correspond to any tasks in the queue\n */\nexport const cancelTask = taskID => queuedTasks.delete(taskID);","// Firefox currently doesn't support modules in web workers yet, so\n// emscripten is compiling to non module code. Relying on rollup+terser\n// to remove all other module imports.\nimportScripts(\"WasmTest.js\");\n\nimport { START_TEST, TEST_STOPPED, TEST_RUNNING, STOP_TEST, WORKER_READY } from \"./CPU-test-event.js\";\nimport { queueTask, cancelTask } from \"../common/utils.js\";\n\nself.Module().then(WasmTest => {\n\n\tlet testStatus = TEST_STOPPED;\n\tlet testDuration = 0;\n\tlet loopCount = 0;\n\tlet testTaskId = undefined;\n\n\tconst testFunction = () => {\n\t\tif (testStatus === TEST_RUNNING) {\n\t\t\tconst startTime = performance.now();\n\t\t\tconst result = WasmTest._runTest();\n\t\t\t// In minutes\n\t\t\ttestDuration += (performance.now() - startTime) / 1000 / 60;\n\t\t\tloopCount++;\n\t\t\t// Currently loops per minute\n\t\t\tconst score = loopCount / testDuration;\n\t\t\ttestTaskId = queueTask(testFunction);\n\t\t\tpostMessage({\n\t\t\t\tstate: testStatus,\n\t\t\t\tscore: score,\n\t\t\t\t// It's highly unlikely that any compiler will optimize across thread boundaries.\n\t\t\t\t// This guarantees that the test won't be optimized away by a future compiler\n\t\t\t\t// that can optimize across JS/WASM boundary.\n\t\t\t\tresult: result,\n\t\t\t});\n\t\t}\n\t};\n\n\tself.addEventListener(\"message\", e => {\n\t\tif ((e.data === START_TEST) && testStatus !== TEST_RUNNING) {\n\t\t\ttestStatus = TEST_RUNNING;\n\t\t\ttestDuration = 0;\n\t\t\tloopCount = 0;\n\t\t\ttestTaskId = queueTask(testFunction);\n\t\t}\n\t\tif ((e.data === STOP_TEST) && testStatus === TEST_RUNNING) {\n\t\t\ttestStatus = TEST_STOPPED;\n\t\t\tcancelTask(testTaskId);\n\t\t\ttestTaskId = undefined;\n\t\t}\n\t});\n\n\tpostMessage({\n\t\tstate: WORKER_READY,\n\t});\n});\n"],"names":["channel","MessageChannel","receiver","port1","sender","port2","queuedTasks","Map","nextTaskID","onmessage","event","taskID","data","has","task","get","delete","queueTask","func","isFunction","Error","currentID","set","postMessage","importScripts","self","Module","then","WasmTest","testStatus","testDuration","loopCount","testTaskId","undefined","testFunction","startTime","performance","now","result","_runTest","score","state","addEventListener","e"],"mappings":"AAAO,MCeDA,EAAU,IAAIC,eACdC,EAAWF,EAAQG,MACnBC,EAASJ,EAAQK,MAIjBC,EAAc,IAAIC,IACxB,IAAIC,EAAa,EAEjBN,EAASO,UAAYC,IACpB,MAAMC,EAASD,EAAME,KACrB,GAAIN,EAAYO,IAAIF,GAAS,CAE5B,MAAMG,EAAOR,EAAYS,IAAIJ,GAC7BL,EAAYU,OAAOL,GACnBG,MAOK,MAAMG,EAAYC,IACxB,IArCyBA,CAAAA,GAA0B,mBAAVA,EAqCpCC,CAAWD,GACf,MAAM,IAAIE,MAAM,kBAGjB,MAAMC,EAAYb,EAKlB,QAJEA,EACFF,EAAYgB,IAAID,EAAWH,GAC3Bd,EAAOmB,YAAYF,GAEZA,GC5CRG,cAAc,eAKdC,KAAKC,SAASC,KAAKC,IAElB,IAAIC,EFLuB,EEMvBC,EAAe,EACfC,EAAY,EACZC,OAAaC,EAEjB,MAAMC,EAAe,KACpB,GFZ0B,IEYtBL,EAA6B,CAChC,MAAMM,EAAYC,YAAYC,MACxBC,EAASV,EAASW,WAExBT,IAAiBM,YAAYC,MAAQF,GAAa,IAAO,GACzDJ,IAEA,MAAMS,EAAQT,EAAYD,EAC1BE,EAAaf,EAAUiB,GACvBX,YAAY,CACXkB,MAAOZ,EACPW,MAAOA,EAIPF,OAAQA,MAKXb,KAAKiB,iBAAiB,UAAWC,IDiBRhC,IAAAA,EDrDA,IEqCnBgC,EAAE/B,MFjCmB,IEiCKiB,IAC9BA,EFlCyB,EEmCzBC,EAAe,EACfC,EAAY,EACZC,EAAaf,EAAUiB,IFxCD,IE0ClBS,EAAE/B,MFvCmB,IEuCIiB,IAC7BA,EFvCyB,ECgDFlB,ECRZqB,EDQsB1B,EAAYU,OAAOL,GCPpDqB,OAAaC,KAIfV,YAAY,CACXkB,MF7C0B"}